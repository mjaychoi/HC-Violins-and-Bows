# 비즈니스 로직 검토 사항

**작성일**: 2025-01-XX  
**목적**: 핵심 비즈니스 규칙 및 로직 검토  
**우선순위**: ⭐⭐⭐⭐⭐ (프로덕션 전 필수)

---

## 📋 검토 항목

### 1. 악기 상태 관리 및 판매 로직

#### 1.1 상태 변경 시 자동 판매 기록 생성

**위치**: `src/app/dashboard/hooks/useDashboardData.ts:117-162`

**현재 로직**:

- 악기 상태를 "Sold"로 변경하고 가격이 있으면 자동으로 `sales_history` 생성
- 중복 생성 방지: 같은 날짜, 같은 악기에 대해 "Auto-created" 노트가 있는 기록이 있으면 생성하지 않음

**검토 사항**:

- [ ] **자동 생성 조건**: 가격 > 0일 때만 생성하는지 확인
- [ ] **중복 방지**: idempotent 로직이 올바르게 작동하는지
- [ ] **클라이언트 연결**: 판매 기록 생성 시 클라이언트 ID가 자동으로 연결되는지
- [ ] **에러 처리**: 판매 기록 생성 실패 시 악기 상태 변경은 성공하는지 (현재는 경고만)
- [ ] **날짜**: 판매 기록의 `sale_date`가 어떤 날짜인지 (상태 변경일? 수동 입력?)

**비즈니스 규칙 확인**:

- [ ] 상태를 "Sold"로 변경할 때 항상 판매 기록이 필요한가?
- [ ] 가격이 없어도 판매 기록을 생성해야 하는가?
- [ ] 판매 기록 생성 실패 시 상태 변경을 롤백해야 하는가?

---

#### 1.2 판매 기록 생성 시 악기 상태 자동 업데이트

**위치**: `src/app/sales/components/SaleForm.tsx:175-200`

**현재 로직**:

- `autoUpdateInstrumentStatus=true`일 때 판매 기록 저장 후 악기 상태를 "Sold"로 변경
- 에러 발생 시에도 판매 기록은 성공 (경고만)

**검토 사항**:

- [ ] **자동 업데이트 조건**: `autoUpdateInstrumentStatus` 플래그가 올바르게 사용되는지
- [ ] **가격 검증**: 가격 > 0일 때만 상태 변경하는지
- [ ] **에러 처리**: 상태 업데이트 실패 시 판매 기록은 유지되는지
- [ ] **트랜잭션**: 두 작업이 원자적으로 처리되어야 하는가?

**비즈니스 규칙 확인**:

- [ ] 판매 기록 생성 시 항상 악기 상태를 "Sold"로 변경해야 하는가?
- [ ] 상태 변경 실패 시 판매 기록을 롤백해야 하는가?
- [ ] 이미 "Sold" 상태인 악기에 대한 판매 기록은 어떻게 처리하는가?

---

#### 1.3 악기 상태 전이 규칙

**위치**: `supabase/migrations/20241112141804_update_status_constraint.sql`

**가능한 상태**: `Available`, `Booked`, `Sold`, `Reserved`, `Maintenance`

**검토 사항**:

- [ ] **상태 전이 규칙**: 모든 상태에서 모든 상태로 전이가 가능한가?
  - 예: `Sold` → `Available` 가능한가? (환불/반품 시나리오)
  - 예: `Maintenance` → `Sold` 가능한가?
- [ ] **상태별 제약사항**: 특정 상태에서는 특정 작업만 가능한가?
  - 예: `Sold` 상태인 악기는 수정 불가?
  - 예: `Maintenance` 상태인 악기는 판매 불가?
- [ ] **상태 변경 이력**: 상태 변경 이력을 추적해야 하는가?

**비즈니스 규칙 확인**:

- [ ] 상태 전이 다이어그램 필요 여부
- [ ] 특정 상태에서만 가능한 작업 정의
- [ ] 상태 변경 시 자동으로 실행되는 작업 정의

---

### 2. Serial Number 생성 및 검증

#### 2.1 Serial Number 생성 로직

**위치**: `src/utils/uniqueNumberGenerator.ts:48-69`

**현재 로직**:

- 형식: `{접두사}{7자리 숫자}` (예: `VI0000001`, `BO0000123`)
- 접두사: 악기 타입에 따라 자동 결정 (Violin→VI, Bow→BO 등)
- 다음 번호: 같은 접두사의 최대값 + 1

**검토 사항**:

- [ ] **접두사 매핑**: 모든 악기 타입에 대한 접두사가 정의되어 있는가?
- [ ] **번호 충돌**: 동시에 여러 악기를 생성할 때 번호 충돌 가능성
- [ ] **NULL 처리**: 타입이 없을 때 "IN" 접두사 사용이 적절한가?
- [ ] **기존 데이터**: 이미 존재하는 Serial Number와의 충돌 방지

**비즈니스 규칙 확인**:

- [ ] Serial Number는 반드시 필요한가? (현재는 선택적)
- [ ] 수동 입력도 허용하는가? (현재는 편집 모드에서만 가능)
- [ ] Serial Number 형식 변경 시 기존 데이터 마이그레이션 필요 여부

---

#### 2.2 Serial Number 검증 로직

**위치**: `src/utils/uniqueNumberGenerator.ts:95-171`

**현재 로직**:

- 형식 검증: `AA0000000` (2글자 + 7자리 숫자)
- 중복 검증: 기존 번호와 중복 확인 (현재 편집 중인 번호 제외)
- 정규화: 공백 제거, 대문자 변환, 숫자 zero-padding

**검토 사항**:

- [ ] **중복 검증 범위**: 전체 악기 목록에서 검증하는가?
- [ ] **편집 시 검증**: 현재 악기의 기존 번호는 제외하는가?
- [ ] **에러 메시지**: 중복 시 어떤 악기와 중복인지 표시하는가?
- [ ] **대소문자**: 대소문자 구분 없이 검증하는가?

**비즈니스 규칙 확인**:

- [ ] Serial Number는 전역적으로 고유해야 하는가?
- [ ] 같은 Serial Number를 다른 악기에 재사용할 수 있는가? (예: 악기 폐기 후)
- [ ] Serial Number 변경 시 이력 추적이 필요한가?

---

### 3. 클라이언트-악기 연결 로직

#### 3.1 연결 생성 및 중복 방지

**위치**: `supabase/migrations/database-schema.sql:69-77`

**현재 제약사항**:

- `UNIQUE(client_id, instrument_id)`: 같은 클라이언트-악기 조합은 하나만 존재
- 관계 타입: `Interested`, `Sold`, `Booked`, `Owned`

**검토 사항**:

- [ ] **중복 연결**: 같은 클라이언트-악기 조합을 다른 관계 타입으로 추가할 수 있는가?
  - 예: `Interested` → `Sold`로 변경 vs 새 연결 생성
- [ ] **관계 타입 전이**: 관계 타입 변경 시 이전 연결을 삭제하고 새로 생성하는가?
- [ ] **CASCADE 삭제**: 악기/클라이언트 삭제 시 연결도 자동 삭제되는가?

**비즈니스 규칙 확인**:

- [ ] 한 클라이언트가 같은 악기에 여러 관계를 가질 수 있는가?
  - 예: `Interested`와 `Booked` 동시에?
- [ ] 관계 타입 우선순위: 여러 관계가 있을 때 어떤 것을 표시하는가?
- [ ] 관계 타입 변경 이력 추적 필요 여부

---

#### 3.2 관계 타입별 비즈니스 규칙

**위치**: `src/types/index.ts:48`

**관계 타입**: `Interested`, `Sold`, `Booked`, `Owned`

**검토 사항**:

- [ ] **Interested**: 관심 있는 악기 - 특별한 제약사항 없음?
- [ ] **Sold**: 판매된 악기 - `sales_history`와 자동 연동되는가?
- [ ] **Booked**: 예약된 악기 - `MaintenanceTask`와 연동되는가?
- [ ] **Owned**: 소유한 악기 - 현재 소유권을 나타내는가?

**비즈니스 규칙 확인**:

- [ ] 각 관계 타입의 의미와 사용 시나리오 명확화
- [ ] 관계 타입별 자동 작업 정의 (예: `Sold` → 판매 기록 생성)
- [ ] 관계 타입 변경 시 자동으로 실행되는 작업

---

### 4. 유지보수 작업 날짜 우선순위

#### 4.1 날짜 우선순위 로직

**위치**: `src/utils/tasks/dateUtils.ts:45-57`, `supabase/functions/send-notifications/index.ts:139-141`

**현재 우선순위**: `due_date` > `personal_due_date` > `scheduled_date`

**검토 사항**:

- [ ] **우선순위 로직**: 모든 곳에서 동일한 우선순위를 사용하는가?
- [ ] **날짜 계산**: 오버듀 계산 시 어떤 날짜를 사용하는가?
- [ ] **알림 날짜**: 알림은 어떤 날짜 기준으로 보내는가?
- [ ] **날짜 충돌**: 여러 날짜가 모두 있을 때 어떤 것을 표시하는가?

**비즈니스 규칙 확인**:

- [ ] 각 날짜의 의미와 용도 명확화
  - `due_date`: 고객 요청 납기일
  - `personal_due_date`: 개인 목표 완료일
  - `scheduled_date`: 예약된 작업일
- [ ] 날짜 우선순위가 비즈니스 요구사항에 맞는가?
- [ ] 날짜가 없을 때 기본값 처리

---

#### 4.2 오버듀 계산 로직

**위치**: `src/utils/tasks/style.ts:127-163`

**현재 로직**:

- 오버듀: `due_date` 또는 `personal_due_date`가 오늘보다 이전
- 업커밍: 3일 이내
- 날짜 계산: `startOfDay` 사용하여 시간 무시

**검토 사항**:

- [ ] **오버듀 기준**: 정확히 언제 오버듀로 간주하는가? (자정 기준?)
- [ ] **업커밍 기간**: 3일이 적절한가? 설정 가능해야 하는가?
- [ ] **타임존**: 서버/클라이언트 타임존 차이 처리
- [ ] **날짜 비교**: `startOfDay` 사용이 올바른가?

**비즈니스 규칙 확인**:

- [ ] 오버듀 정의: 하루가 지나면 오버듀인가? 아니면 시간까지 고려?
- [ ] 업커밍 알림: 며칠 전에 알림을 보내야 하는가?
- [ ] 오늘 날짜 작업: 오늘 날짜 작업은 어떤 카테고리에 속하는가?

---

### 5. 가격/금액 검증 및 처리

#### 5.1 판매 가격 검증

**위치**: `src/app/api/sales/route.ts:389-395`

**현재 규칙**:

- 가격은 필수
- 가격은 숫자여야 함
- **0원 금액은 허용하지 않음** (비즈니스 규칙)

**검토 사항**:

- [ ] **0원 금액**: 정말 0원을 허용하지 않아야 하는가?
  - 예: 무료 수리, 교환, 프로모션 등
- [ ] **음수 금액**: 음수 금액이 필요한 시나리오가 있는가? (환불?)
- [ ] **소수점**: 소수점 가격이 필요한가? (현재는 DECIMAL(10,2) 사용)
- [ ] **최대값**: 가격에 상한선이 필요한가?

**비즈니스 규칙 확인**:

- [ ] 0원 판매/서비스가 가능한 비즈니스 모델인가?
- [ ] 환불 처리는 어떻게 하는가? (음수 금액? 별도 테이블?)
- [ ] 가격 정책: 할인, 프로모션 등 특수 가격 처리

---

#### 5.2 악기 가격 처리

**위치**: `src/app/dashboard/components/ItemForm.tsx`

**현재 로직**:

- 가격은 선택적 (nullable)
- 숫자 형식 검증
- 콤마 제거 후 저장

**검토 사항**:

- [ ] **가격 표시**: 가격이 없을 때 어떻게 표시하는가? ("N/A", "—", 빈 값?)
- [ ] **가격 형식**: 통화 기호, 소수점, 천 단위 구분자 표시
- [ ] **가격 업데이트**: 가격 변경 시 이력 추적이 필요한가?
- [ ] **판매 가격과의 관계**: 악기 가격과 판매 기록의 가격이 다를 수 있는가?

**비즈니스 규칙 확인**:

- [ ] 악기 가격은 판매 가격의 기본값인가?
- [ ] 가격 협상: 판매 시 가격이 변경될 수 있는가?
- [ ] 가격 정책: 가격 변경 시 승인 프로세스가 필요한가?

---

### 6. 데이터 무결성 규칙

#### 6.1 외래키 제약사항

**위치**: `supabase/migrations/database-schema.sql`

**현재 제약사항**:

- `sales_history.instrument_id`: `ON DELETE CASCADE`
- `sales_history.client_id`: `ON DELETE SET NULL`
- `client_instruments`: `ON DELETE CASCADE` (양쪽 모두)

**검토 사항**:

- [ ] **CASCADE 삭제**: 악기 삭제 시 판매 기록도 삭제되는 것이 맞는가?
  - 대안: `ON DELETE SET NULL` 또는 `ON DELETE RESTRICT`
- [ ] **SET NULL**: 클라이언트 삭제 시 판매 기록의 클라이언트가 NULL이 되는 것이 맞는가?
- [ ] **연결 삭제**: 악기/클라이언트 삭제 시 연결도 자동 삭제되는 것이 맞는가?

**비즈니스 규칙 확인**:

- [ ] 데이터 보존 정책: 삭제된 악기/클라이언트의 기록을 보존해야 하는가?
- [ ] 감사 추적: 삭제 이력을 추적해야 하는가?
- [ ] 소프트 삭제: 실제 삭제 대신 `deleted_at` 플래그 사용?

---

#### 6.2 고유성 제약사항

**위치**: `supabase/migrations/20250101000001_add_unique_numbers.sql`

**현재 제약사항**:

- `instruments.serial_number`: UNIQUE (NULL 허용)
- `clients.client_number`: UNIQUE (NULL 허용)

**검토 사항**:

- [ ] **NULL 허용**: Serial Number가 NULL인 악기가 여러 개 있을 수 있는가?
- [ ] **고유성 범위**: Serial Number는 전역적으로 고유해야 하는가?
- [ ] **재사용**: 삭제된 악기의 Serial Number를 재사용할 수 있는가?

**비즈니스 규칙 확인**:

- [ ] Serial Number는 필수인가 선택인가?
- [ ] Serial Number 재사용 정책
- [ ] 중복 방지 전략

---

### 7. 자동화 및 트리거 로직

#### 7.1 자동 판매 기록 생성

**위치**: `src/app/dashboard/hooks/useDashboardData.ts:117-162`

**검토 사항**:

- [ ] **트랜잭션**: 악기 상태 변경과 판매 기록 생성이 원자적으로 처리되는가?
- [ ] **에러 처리**: 판매 기록 생성 실패 시 상태 변경을 롤백해야 하는가?
- [ ] **중복 방지**: 동시 요청 시 중복 생성 방지
- [ ] **로깅**: 자동 생성된 기록을 구분할 수 있는가? (notes 필드)

**비즈니스 규칙 확인**:

- [ ] 자동 생성 vs 수동 생성: 언제 자동으로 생성하고 언제 수동으로 생성하는가?
- [ ] 자동 생성된 기록 수정 가능 여부
- [ ] 자동 생성 로직 변경 시 기존 데이터 영향

---

#### 7.2 자동 상태 업데이트

**위치**: `src/app/sales/components/SaleForm.tsx:175-200`

**검토 사항**:

- [ ] **조건부 업데이트**: 모든 판매 기록 생성 시 상태를 변경해야 하는가?
- [ ] **이미 Sold**: 이미 "Sold" 상태인 악기에 대한 처리
- [ ] **에러 처리**: 상태 업데이트 실패 시 판매 기록 롤백 여부
- [ ] **트랜잭션**: 두 작업의 원자성 보장

**비즈니스 규칙 확인**:

- [ ] 판매 기록과 악기 상태의 일관성 유지 방법
- [ ] 상태 변경 실패 시 재시도 로직
- [ ] 수동 상태 변경과의 충돌 방지

---

### 8. 날짜 및 시간 처리

#### 8.1 날짜 형식 및 타임존

**위치**: 여러 파일

**검토 사항**:

- [ ] **날짜 형식**: 모든 곳에서 `YYYY-MM-DD` 형식을 일관되게 사용하는가?
- [ ] **타임존**: 서버/클라이언트 타임존 차이 처리
- [ ] **날짜 비교**: `startOfDay` 사용으로 시간 무시하는 것이 올바른가?
- [ ] **날짜 파싱**: 날짜 문자열 파싱 시 타임존 이슈

**비즈니스 규칙 확인**:

- [ ] 비즈니스 로직에서 사용하는 타임존 (서버 시간? 로컬 시간?)
- [ ] 날짜 경계 처리 (자정 기준)
- [ ] 날짜 표시 형식 (로케일별)

---

#### 8.2 날짜 검증

**위치**: `src/app/api/sales/route.ts:373-378`

**검토 사항**:

- [ ] **미래 날짜**: 판매 날짜가 미래일 수 있는가?
- [ ] **과거 날짜**: 판매 날짜가 과거일 수 있는가? (역사적 데이터 입력)
- [ ] **날짜 범위**: 유효한 날짜 범위 제한이 필요한가?
- [ ] **날짜 형식**: 모든 날짜 입력에서 형식 검증

**비즈니스 규칙 확인**:

- [ ] 판매 날짜 정책: 오늘 이후 판매 가능?
- [ ] 유지보수 작업 날짜: 미래 날짜만 허용?
- [ ] 날짜 수정: 생성 후 날짜 수정 가능 여부

---

### 9. 권한 및 접근 제어

#### 9.1 RLS (Row Level Security) 정책

**위치**: `supabase/migrations/database-schema.sql:90-113`

**현재 정책**:

- 모든 인증된 사용자가 모든 작업 가능

**검토 사항**:

- [ ] **접근 제어**: 현재 정책이 프로덕션에 적합한가?
- [ ] **역할 기반**: 관리자/일반 사용자 구분이 필요한가?
- [ ] **데이터 격리**: 사용자별 데이터 격리가 필요한가?
- [ ] **읽기/쓰기 분리**: 읽기와 쓰기 권한을 분리해야 하는가?

**비즈니스 규칙 확인**:

- [ ] 다중 사용자 지원 필요 여부
- [ ] 권한 모델: 어떤 사용자가 어떤 작업을 할 수 있는가?
- [ ] 감사 로그: 누가 무엇을 했는지 추적 필요 여부

---

### 10. 에러 처리 및 복구

#### 10.1 부분 실패 처리

**위치**: 여러 파일

**현재 패턴**:

- 판매 기록 생성 실패 시 악기 상태 변경은 성공 (경고만)
- 상태 업데이트 실패 시 판매 기록은 성공 (경고만)

**검토 사항**:

- [ ] **원자성**: 관련 작업들이 원자적으로 처리되어야 하는가?
- [ ] **롤백**: 일부 실패 시 전체 롤백이 필요한가?
- [ ] **재시도**: 실패한 작업을 자동으로 재시도해야 하는가?
- [ ] **에러 알림**: 사용자에게 명확한 에러 메시지 제공

**비즈니스 규칙 확인**:

- [ ] 데이터 일관성: 어떤 상황에서도 일관성을 유지해야 하는가?
- [ ] 복구 전략: 부분 실패 시 수동 복구 프로세스
- [ ] 모니터링: 실패한 작업을 모니터링하고 알림

---

## ✅ 체크리스트

### 필수 검토 (프로덕션 전)

- [ ] 악기 상태 전이 규칙 명확화
- [ ] 판매 기록과 악기 상태의 일관성 보장
- [ ] Serial Number 고유성 보장
- [ ] 가격 검증 규칙 (0원 허용 여부)
- [ ] 날짜 처리 및 타임존 일관성
- [ ] 데이터 삭제 정책 (CASCADE vs SET NULL)
- [ ] 트랜잭션 및 원자성 보장

### 권장 검토

- [ ] 관계 타입별 비즈니스 규칙 명확화
- [ ] 자동화 로직의 에러 처리 개선
- [ ] 권한 및 접근 제어 강화
- [ ] 감사 로그 및 이력 추적

---

## 📝 참고 파일

### 핵심 비즈니스 로직

- **악기 상태 관리**: `src/app/dashboard/hooks/useDashboardData.ts`
- **판매 로직**: `src/app/sales/components/SaleForm.tsx`, `src/app/api/sales/route.ts`
- **Serial Number**: `src/utils/uniqueNumberGenerator.ts`
- **연결 관리**: `src/app/api/connections/route.ts`
- **유지보수 작업**: `src/utils/tasks/dateUtils.ts`, `src/utils/tasks/style.ts`

### 데이터베이스 스키마

- **마이그레이션**: `supabase/migrations/`
- **제약사항**: `supabase/migrations/database-schema.sql`

---

## 🚨 중요 결정 사항

### 1. 판매 기록과 악기 상태의 관계

- **현재**: 양방향 자동 업데이트 (상태 변경 → 판매 기록, 판매 기록 → 상태 변경)
- **문제**: 부분 실패 시 일관성 깨짐
- **결정 필요**: 트랜잭션으로 원자성 보장? 또는 수동 동기화?

### 2. 0원 금액 허용 여부

- **현재**: 0원 금액 불허
- **문제**: 무료 서비스, 프로모션 등 처리 불가
- **결정 필요**: 0원 허용? 또는 별도 플래그?

### 3. Serial Number 필수 여부

- **현재**: 선택적 (NULL 허용)
- **문제**: NULL인 악기가 여러 개 가능
- **결정 필요**: 필수로 변경? 또는 NULL 허용 유지?

### 4. 데이터 삭제 정책

- **현재**: CASCADE 삭제 (악기 삭제 시 판매 기록도 삭제)
- **문제**: 판매 이력 손실
- **결정 필요**: SET NULL 또는 RESTRICT? 또는 소프트 삭제?

---

**검토자**: **\*\***\_\_\_**\*\***  
**검토일**: **\*\***\_\_\_**\*\***  
**다음 검토일**: **\*\***\_\_\_**\*\***
